<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGAL 5.1 - Octree: CGAL::Octree::Node&lt; Point_index &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
      }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png"
           onmouseover="return searchBox.OnSearchSelectShow()"
           onmouseout="return searchBox.OnSearchSelectHide()"
           alt=""/>
      <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)"
             onblur="searchBox.OnSearchFieldFocus(false)"
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt=""/></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.1 - Octree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classCGAL_1_1Octree_1_1Node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Octree_1_1Node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CGAL::Octree::Node&lt; Point_index &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgOctreeRef.html">Octree Reference</a> &raquo; <a class="el" href="group__PkgOctreeClasses.html">Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Octree/Node.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><h3>template&lt;typename Point_index&gt;<br />
class CGAL::Octree::Node&lt; Point_index &gt;</h3>

<p>represents a single node of the tree. Alternatively referred to as a cell, octant, or subtree </p>
<p>The role of the node isn't fully stable yet</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Point_index</td><td>is the datatype the node will contain </td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Types</h2></td></tr>
<tr class="memitem:a16acb36f5708cf4ed356e3d4f64f4d99"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a16acb36f5708cf4ed356e3d4f64f4d99">Child</a> </td></tr>
<tr class="memdesc:a16acb36f5708cf4ed356e3d4f64f4d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">the index of a node relative to its parent (a position defined by the corners of a cube)  <a href="classCGAL_1_1Octree_1_1Node.html#a16acb36f5708cf4ed356e3d4f64f4d99">More...</a><br /></td></tr>
<tr class="separator:a16acb36f5708cf4ed356e3d4f64f4d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649c9825d35c8ff210afa1b721f3e249"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a649c9825d35c8ff210afa1b721f3e249">Direction</a> </td></tr>
<tr class="memdesc:a649c9825d35c8ff210afa1b721f3e249"><td class="mdescLeft">&#160;</td><td class="mdescRight">two directions along each axis in cartesian space, relative to a node  <a href="classCGAL_1_1Octree_1_1Node.html#a649c9825d35c8ff210afa1b721f3e249">More...</a><br /></td></tr>
<tr class="separator:a649c9825d35c8ff210afa1b721f3e249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6948f4082832147a7964339b9e115e7"><td class="memItemLeft" align="right" valign="top"><a id="ac6948f4082832147a7964339b9e115e7"></a>
typedef <a class="el" href="classCGAL_1_1Octree_1_1Node.html">Node</a>&lt; Point_index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a></td></tr>
<tr class="memdesc:ac6948f4082832147a7964339b9e115e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">self typedef for convenience <br /></td></tr>
<tr class="separator:ac6948f4082832147a7964339b9e115e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f636c5e07c2c3a516750bc8e261017d"><td class="memItemLeft" align="right" valign="top"><a id="a6f636c5e07c2c3a516750bc8e261017d"></a>
typedef std::array&lt; <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a6f636c5e07c2c3a516750bc8e261017d">Children</a></td></tr>
<tr class="memdesc:a6f636c5e07c2c3a516750bc8e261017d"><td class="mdescLeft">&#160;</td><td class="mdescRight">array for containing the child nodes of this node <br /></td></tr>
<tr class="separator:a6f636c5e07c2c3a516750bc8e261017d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55b53ed8b9965ba83c3c596265dffab"><td class="memItemLeft" align="right" valign="top">typedef std::bitset&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#af55b53ed8b9965ba83c3c596265dffab">Index</a></td></tr>
<tr class="memdesc:af55b53ed8b9965ba83c3c596265dffab"><td class="mdescLeft">&#160;</td><td class="mdescRight">set of bits representing this node's relationship to its parent  <a href="classCGAL_1_1Octree_1_1Node.html#af55b53ed8b9965ba83c3c596265dffab">More...</a><br /></td></tr>
<tr class="separator:af55b53ed8b9965ba83c3c596265dffab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a88474d71b9c972e491a04e5c60731"><td class="memItemLeft" align="right" valign="top">typedef std::array&lt; uint32_t, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#ae8a88474d71b9c972e491a04e5c60731">Int_location</a></td></tr>
<tr class="memdesc:ae8a88474d71b9c972e491a04e5c60731"><td class="mdescLeft">&#160;</td><td class="mdescRight">coordinate location representing this node's relationship with the rest of the tree  <a href="classCGAL_1_1Octree_1_1Node.html#ae8a88474d71b9c972e491a04e5c60731">More...</a><br /></td></tr>
<tr class="separator:ae8a88474d71b9c972e491a04e5c60731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb076b3af39fb38303fdf0879b6ecf7"><td class="memItemLeft" align="right" valign="top"><a id="a6eb076b3af39fb38303fdf0879b6ecf7"></a>
typedef boost::iterator_range&lt; Point_index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a6eb076b3af39fb38303fdf0879b6ecf7">Point_range</a></td></tr>
<tr class="memdesc:a6eb076b3af39fb38303fdf0879b6ecf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">a collection of point indices represented by begin and end iterators <br /></td></tr>
<tr class="separator:a6eb076b3af39fb38303fdf0879b6ecf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Construction</h2></td></tr>
<tr class="memitem:ab7de778a9c4df63eaec10db77beb1fad"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#ab7de778a9c4df63eaec10db77beb1fad">Node</a> (<a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> *<a class="el" href="classCGAL_1_1Octree_1_1Node.html#a817713779475dee12f1d339e445b94eb">parent</a>=nullptr, <a class="el" href="classCGAL_1_1Octree_1_1Node.html#af55b53ed8b9965ba83c3c596265dffab">Index</a> <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ab8edbcaeffa0466743b8e61f266d4a75">index</a>=0)</td></tr>
<tr class="memdesc:ab7de778a9c4df63eaec10db77beb1fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new node, optionally as the child of a parent  <a href="classCGAL_1_1Octree_1_1Node.html#ab7de778a9c4df63eaec10db77beb1fad">More...</a><br /></td></tr>
<tr class="separator:ab7de778a9c4df63eaec10db77beb1fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Mutators</h2></td></tr>
<tr class="memitem:af6428be9387b9a7833f3158cca857852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#af6428be9387b9a7833f3158cca857852">split</a> ()</td></tr>
<tr class="memdesc:af6428be9387b9a7833f3158cca857852"><td class="mdescLeft">&#160;</td><td class="mdescRight">split a node into subnodes  <a href="classCGAL_1_1Octree_1_1Node.html#af6428be9387b9a7833f3158cca857852">More...</a><br /></td></tr>
<tr class="separator:af6428be9387b9a7833f3158cca857852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607dfbe8e6346c4968b3354d8e6c5995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a607dfbe8e6346c4968b3354d8e6c5995">unsplit</a> ()</td></tr>
<tr class="memdesc:a607dfbe8e6346c4968b3354d8e6c5995"><td class="mdescLeft">&#160;</td><td class="mdescRight">eliminate this node's children, making it a leaf node  <a href="classCGAL_1_1Octree_1_1Node.html#a607dfbe8e6346c4968b3354d8e6c5995">More...</a><br /></td></tr>
<tr class="separator:a607dfbe8e6346c4968b3354d8e6c5995"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Child Accessors</h2></td></tr>
<tr class="memitem:a9c5984be6e40f35f72c625e85adafcad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a9c5984be6e40f35f72c625e85adafcad">operator[]</a> (int <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ab8edbcaeffa0466743b8e61f266d4a75">index</a>)</td></tr>
<tr class="memdesc:a9c5984be6e40f35f72c625e85adafcad"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the child nodes of this node by their indices  <a href="classCGAL_1_1Octree_1_1Node.html#a9c5984be6e40f35f72c625e85adafcad">More...</a><br /></td></tr>
<tr class="separator:a9c5984be6e40f35f72c625e85adafcad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67327ed00e04cd4d703be4b706b5997"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#aa67327ed00e04cd4d703be4b706b5997">operator[]</a> (int <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ab8edbcaeffa0466743b8e61f266d4a75">index</a>) const</td></tr>
<tr class="memdesc:aa67327ed00e04cd4d703be4b706b5997"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only access the child nodes of this node by their indices  <a href="classCGAL_1_1Octree_1_1Node.html#aa67327ed00e04cd4d703be4b706b5997">More...</a><br /></td></tr>
<tr class="separator:aa67327ed00e04cd4d703be4b706b5997"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Property Accessors</h2></td></tr>
<tr class="memitem:a817713779475dee12f1d339e445b94eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a817713779475dee12f1d339e445b94eb">parent</a> () const</td></tr>
<tr class="memdesc:a817713779475dee12f1d339e445b94eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only access to this node's parent  <a href="classCGAL_1_1Octree_1_1Node.html#a817713779475dee12f1d339e445b94eb">More...</a><br /></td></tr>
<tr class="separator:a817713779475dee12f1d339e445b94eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81631df1ac6192584eca090e27a006cd"><td class="memItemLeft" align="right" valign="top">const uint8_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a81631df1ac6192584eca090e27a006cd">depth</a> () const</td></tr>
<tr class="memdesc:a81631df1ac6192584eca090e27a006cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve this node's depth in the tree  <a href="classCGAL_1_1Octree_1_1Node.html#a81631df1ac6192584eca090e27a006cd">More...</a><br /></td></tr>
<tr class="separator:a81631df1ac6192584eca090e27a006cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859e011f27c0c57a302c19044366ce95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#ae8a88474d71b9c972e491a04e5c60731">Int_location</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a859e011f27c0c57a302c19044366ce95">location</a> () const</td></tr>
<tr class="memdesc:a859e011f27c0c57a302c19044366ce95"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve this node's location in the tree  <a href="classCGAL_1_1Octree_1_1Node.html#a859e011f27c0c57a302c19044366ce95">More...</a><br /></td></tr>
<tr class="separator:a859e011f27c0c57a302c19044366ce95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8edbcaeffa0466743b8e61f266d4a75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#af55b53ed8b9965ba83c3c596265dffab">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#ab8edbcaeffa0466743b8e61f266d4a75">index</a> () const</td></tr>
<tr class="memdesc:ab8edbcaeffa0466743b8e61f266d4a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">retrieve this node's index in relation to its parent  <a href="classCGAL_1_1Octree_1_1Node.html#ab8edbcaeffa0466743b8e61f266d4a75">More...</a><br /></td></tr>
<tr class="separator:ab8edbcaeffa0466743b8e61f266d4a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea03580a944c3e09be51ddf893ca17a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a4ea03580a944c3e09be51ddf893ca17a">is_leaf</a> () const</td></tr>
<tr class="memdesc:a4ea03580a944c3e09be51ddf893ca17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine whether this node is a leaf node  <a href="classCGAL_1_1Octree_1_1Node.html#a4ea03580a944c3e09be51ddf893ca17a">More...</a><br /></td></tr>
<tr class="separator:a4ea03580a944c3e09be51ddf893ca17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcd0af02a9b11d50d6bf668053a6426"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#acdcd0af02a9b11d50d6bf668053a6426">is_root</a> () const</td></tr>
<tr class="memdesc:acdcd0af02a9b11d50d6bf668053a6426"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine whether this node is the root node  <a href="classCGAL_1_1Octree_1_1Node.html#acdcd0af02a9b11d50d6bf668053a6426">More...</a><br /></td></tr>
<tr class="separator:acdcd0af02a9b11d50d6bf668053a6426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c76e5b5e46cb474b88068885f14614e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a1c76e5b5e46cb474b88068885f14614e">adjacent_node</a> (std::bitset&lt; 3 &gt; direction) const</td></tr>
<tr class="memdesc:a1c76e5b5e46cb474b88068885f14614e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the directly adjacent node in a specific direction  <a href="classCGAL_1_1Octree_1_1Node.html#a1c76e5b5e46cb474b88068885f14614e">More...</a><br /></td></tr>
<tr class="separator:a1c76e5b5e46cb474b88068885f14614e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7ab78f233eec83ed00c6b0e3a2b761"><td class="memItemLeft" align="right" valign="top"><a id="a8b7ab78f233eec83ed00c6b0e3a2b761"></a>
const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a8b7ab78f233eec83ed00c6b0e3a2b761">adjacent_node</a> (<a class="el" href="classCGAL_1_1Octree_1_1Node.html#a649c9825d35c8ff210afa1b721f3e249">Direction</a> direction) const</td></tr>
<tr class="memdesc:a8b7ab78f233eec83ed00c6b0e3a2b761"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to adjacent_node, with a Direction rather than a bitset <br /></td></tr>
<tr class="separator:a8b7ab78f233eec83ed00c6b0e3a2b761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0d01354a6c047533d830941e52c2f0"><td class="memItemLeft" align="right" valign="top"><a id="a3e0d01354a6c047533d830941e52c2f0"></a>
<a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a3e0d01354a6c047533d830941e52c2f0">adjacent_node</a> (std::bitset&lt; 3 &gt; direction)</td></tr>
<tr class="memdesc:a3e0d01354a6c047533d830941e52c2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to adjacent_node, except non-const <br /></td></tr>
<tr class="separator:a3e0d01354a6c047533d830941e52c2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace3855b9c85473f03297dcad679ccd1"><td class="memItemLeft" align="right" valign="top"><a id="aace3855b9c85473f03297dcad679ccd1"></a>
<a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#aace3855b9c85473f03297dcad679ccd1">adjacent_node</a> (<a class="el" href="classCGAL_1_1Octree_1_1Node.html#a649c9825d35c8ff210afa1b721f3e249">Direction</a> direction)</td></tr>
<tr class="memdesc:aace3855b9c85473f03297dcad679ccd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">equivalent to adjacent_node, with a Direction rather than a bitset and non-const <br /></td></tr>
<tr class="separator:aace3855b9c85473f03297dcad679ccd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Value Accessors</h2></td></tr>
<tr class="memitem:a7d5b29eac2b539cb75c3a08b2befa7e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a6eb076b3af39fb38303fdf0879b6ecf7">Point_range</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a7d5b29eac2b539cb75c3a08b2befa7e6">points</a> ()</td></tr>
<tr class="memdesc:a7d5b29eac2b539cb75c3a08b2befa7e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">access to the content held by this node  <a href="classCGAL_1_1Octree_1_1Node.html#a7d5b29eac2b539cb75c3a08b2befa7e6">More...</a><br /></td></tr>
<tr class="separator:a7d5b29eac2b539cb75c3a08b2befa7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8063c67e27eeb6ceb9c76d70b86890bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#a6eb076b3af39fb38303fdf0879b6ecf7">Point_range</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a8063c67e27eeb6ceb9c76d70b86890bd">points</a> () const</td></tr>
<tr class="memdesc:a8063c67e27eeb6ceb9c76d70b86890bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">read-only access to the content held by this node  <a href="classCGAL_1_1Octree_1_1Node.html#a8063c67e27eeb6ceb9c76d70b86890bd">More...</a><br /></td></tr>
<tr class="separator:a8063c67e27eeb6ceb9c76d70b86890bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0d8664d6e3b2033d630f2aa2b981d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#afe0d8664d6e3b2033d630f2aa2b981d2">empty</a> () const</td></tr>
<tr class="memdesc:afe0d8664d6e3b2033d630f2aa2b981d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether this node contains any points  <a href="classCGAL_1_1Octree_1_1Node.html#afe0d8664d6e3b2033d630f2aa2b981d2">More...</a><br /></td></tr>
<tr class="separator:afe0d8664d6e3b2033d630f2aa2b981d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01638decf3e8638c656174d30b8b8b05"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a01638decf3e8638c656174d30b8b8b05">size</a> () const</td></tr>
<tr class="memdesc:a01638decf3e8638c656174d30b8b8b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">count the points contained by this node  <a href="classCGAL_1_1Octree_1_1Node.html#a01638decf3e8638c656174d30b8b8b05">More...</a><br /></td></tr>
<tr class="separator:a01638decf3e8638c656174d30b8b8b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Operators</h2></td></tr>
<tr class="memitem:ae4b44de9d97a6b632ced96b55de3af18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#ae4b44de9d97a6b632ced96b55de3af18">operator==</a> (const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ae4b44de9d97a6b632ced96b55de3af18"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare the topology of this node to another node  <a href="classCGAL_1_1Octree_1_1Node.html#ae4b44de9d97a6b632ced96b55de3af18">More...</a><br /></td></tr>
<tr class="separator:ae4b44de9d97a6b632ced96b55de3af18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56958185e0714a6c6c7fb78a8c94f637"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a56958185e0714a6c6c7fb78a8c94f637">operator!=</a> (const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a56958185e0714a6c6c7fb78a8c94f637"><td class="mdescLeft">&#160;</td><td class="mdescRight">compares the topology of this node to another node  <a href="classCGAL_1_1Octree_1_1Node.html#a56958185e0714a6c6c7fb78a8c94f637">More...</a><br /></td></tr>
<tr class="separator:a56958185e0714a6c6c7fb78a8c94f637"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af55b53ed8b9965ba83c3c596265dffab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55b53ed8b9965ba83c3c596265dffab">&#9670;&nbsp;</a></span>Index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::bitset&lt;3&gt; <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::<a class="el" href="classCGAL_1_1Octree_1_1Node.html#af55b53ed8b9965ba83c3c596265dffab">Index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set of bits representing this node's relationship to its parent </p>
<p>Equivalent to an array of three booleans, where index[0] is whether x is greater, index[1] is whether y is greater, and index[2] is whether z is greater. Used to represent a node's relationship to the center of its parent. </p>

</div>
</div>
<a id="ae8a88474d71b9c972e491a04e5c60731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a88474d71b9c972e491a04e5c60731">&#9670;&nbsp;</a></span>Int_location</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::array&lt;uint32_t, 3&gt; <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::<a class="el" href="classCGAL_1_1Octree_1_1Node.html#ae8a88474d71b9c972e491a04e5c60731">Int_location</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>coordinate location representing this node's relationship with the rest of the tree </p>
<p>Each value (x, y, z) of a location is calculated by doubling the parent's location and adding the Index. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Maybe I should add an example? </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a16acb36f5708cf4ed356e3d4f64f4d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16acb36f5708cf4ed356e3d4f64f4d99">&#9670;&nbsp;</a></span>Child</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCGAL_1_1Octree_1_1Node.html#a16acb36f5708cf4ed356e3d4f64f4d99">CGAL::Octree::Node::Child</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the index of a node relative to its parent (a position defined by the corners of a cube) </p>
<p>Corners are mapped to numbers as 3-bit integers, in "zyx" order.</p>
<p>For example: </p><blockquote class="doxtable">
<p>right-top-back --&gt; x=1, y=1, z=0 --&gt; zyx = 011 --&gt; 3 </p>
</blockquote>
<p>The following diagram may be a useful reference: </p><pre class="fragment">      6          7
       +--------+
      /|       /|             y+
     / |      / |             *  z+
  2 +--------+ 3|             | *
    |  |     |  |             |/
    |  +-----|--+             +-----* x+
    | / 4    | / 5
    |/       |/
    +--------+
  0           1
</pre><p>This lookup table may also be helpful:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Child </th><th class="markdownTableHeadNone">bitset </th><th class="markdownTableHeadNone">number </th><th class="markdownTableHeadNone">Enum  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">left, bottom, back </td><td class="markdownTableBodyNone">000 </td><td class="markdownTableBodyNone">0 </td><td class="markdownTableBodyNone">LEFT_BOTTOM_BACK  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">right, bottom, back </td><td class="markdownTableBodyNone">001 </td><td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">RIGHT_BOTTOM_BACK  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">left, top, back </td><td class="markdownTableBodyNone">010 </td><td class="markdownTableBodyNone">2 </td><td class="markdownTableBodyNone">LEFT_TOP_BACK  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">right, top, back </td><td class="markdownTableBodyNone">011 </td><td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">RIGHT_TOP_BACK  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">left, bottom, front </td><td class="markdownTableBodyNone">100 </td><td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">LEFT_BOTTOM_FRONT  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">right, bottom, front </td><td class="markdownTableBodyNone">101 </td><td class="markdownTableBodyNone">5 </td><td class="markdownTableBodyNone">RIGHT_BOTTOM_FRONT  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">left, top, front </td><td class="markdownTableBodyNone">110 </td><td class="markdownTableBodyNone">6 </td><td class="markdownTableBodyNone">LEFT_TOP_FRONT  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">right, top, front </td><td class="markdownTableBodyNone">111 </td><td class="markdownTableBodyNone">7 </td><td class="markdownTableBodyNone">RIGHT_TOP_FRONT  </td></tr>
</table>

</div>
</div>
<a id="a649c9825d35c8ff210afa1b721f3e249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649c9825d35c8ff210afa1b721f3e249">&#9670;&nbsp;</a></span>Direction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classCGAL_1_1Octree_1_1Node.html#a649c9825d35c8ff210afa1b721f3e249">CGAL::Octree::Node::Direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>two directions along each axis in cartesian space, relative to a node </p>
<p>Directions are mapped to numbers as 3-bit integers, though the numbers 6 and 7 are not used because there are only 6 different directions.</p>
<p>The first two bits indicate the axis (00 = x, 01 = y, 10 = z), the third bit indicates the direction along that axis (0 = -, 1 = +).</p>
<p>The following diagram may be a useful reference: </p><pre class="fragment">       3 *
         |  * 5
         | /                  y+
         |/                   *  z+
0 *------+------* 1           | *
        /|                    |/
       / |                    +-----* x+
    4 *  |
         * 2
</pre><p>This lookup table may also be helpful:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Direction </th><th class="markdownTableHeadNone">bitset </th><th class="markdownTableHeadNone">number </th><th class="markdownTableHeadNone">Enum  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-x</code> </td><td class="markdownTableBodyNone">000 </td><td class="markdownTableBodyNone">0 </td><td class="markdownTableBodyNone">LEFT  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>+x</code> </td><td class="markdownTableBodyNone">001 </td><td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">RIGHT  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-y</code> </td><td class="markdownTableBodyNone">010 </td><td class="markdownTableBodyNone">2 </td><td class="markdownTableBodyNone">DOWN  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>+y</code> </td><td class="markdownTableBodyNone">011 </td><td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">UP  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>-z</code> </td><td class="markdownTableBodyNone">100 </td><td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">BACK  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>+z</code> </td><td class="markdownTableBodyNone">101 </td><td class="markdownTableBodyNone">5 </td><td class="markdownTableBodyNone">FRONT  </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab7de778a9c4df63eaec10db77beb1fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7de778a9c4df63eaec10db77beb1fad">&#9670;&nbsp;</a></span>Node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::<a class="el" href="classCGAL_1_1Octree_1_1Node.html">Node</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#af55b53ed8b9965ba83c3c596265dffab">Index</a>&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>creates a new node, optionally as the child of a parent </p>
<p>If no parent is provided, the node created is assumed to be the root of a tree. This means that the parent reference is a nullptr, and the depth is zero. If a parent is provided, the node becomes the child of that parent. In that case, an index should be passed, telling this node its relationship to its parent. Depth and location are automatically determined in the constructor, and should generally be considered immutable after construction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>A reference to the node containing this one </td></tr>
    <tr><td class="paramname">index</td><td>This node's relationship to its parent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1c76e5b5e46cb474b88068885f14614e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c76e5b5e46cb474b88068885f14614e">&#9670;&nbsp;</a></span>adjacent_node()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a>* <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::adjacent_node </td>
          <td>(</td>
          <td class="paramtype">std::bitset&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>direction</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the directly adjacent node in a specific direction </p>
<p>Adjacent nodes are found according to several properties:</p><ul>
<li>Adjacent nodes may be larger than the seek node, but never smaller</li>
<li>A node can have no more than 6 different adjacent nodes (left, right, up, down, front, back)</li>
<li>A node is free to have fewer than 6 adjacent nodes (e.g. edge nodes have no neighbors in some directions, the root node has none at all).</li>
<li>Adjacent nodes are not required to be leaf nodes</li>
</ul>
<p>Here's a diagram demonstrating the concept for a quadtree. Because it's in 2d space, the seek node has only four neighbors (up, down, left, right) </p><pre class="fragment">+---------------+---------------+
|               |               |
|               |               |
|               |               |
|       A       |               |
|               |               |
|               |               |
|               |               |
+-------+-------+---+---+-------+
|       |       |   |   |       |
|   A   |  (S)  +---A---+       |
|       |       |   |   |       |
+---+---+-------+---+---+-------+
|   |   |       |       |       |
+---+---+   A   |       |       |
|   |   |       |       |       |
+---+---+-------+-------+-------+

    (S) : Seek node
     A  : Adjacent node
</pre><p>Note how the top adjacent node is larger than the seek node. The right adjacent node is the same size, even though it contains further subdivisions.</p>
<p>This implementation returns a pointer to the adjacent node if it's found. If there is no adjacent node in that direction, it returns nullptr.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>explain how direction is encoded</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">direction</td><td>which way to find the adjacent node relative to this one </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the adjacent node if it exists </dd></dl>

</div>
</div>
<a id="a81631df1ac6192584eca090e27a006cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81631df1ac6192584eca090e27a006cd">&#9670;&nbsp;</a></span>depth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t&amp; <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve this node's depth in the tree </p>
<dl class="section return"><dt>Returns</dt><dd>the depth of this node, where root has a depth of 0 </dd></dl>

</div>
</div>
<a id="afe0d8664d6e3b2033d630f2aa2b981d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0d8664d6e3b2033d630f2aa2b981d2">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether this node contains any points </p>
<dl class="section return"><dt>Returns</dt><dd>if this node contains no points </dd></dl>

</div>
</div>
<a id="ab8edbcaeffa0466743b8e61f266d4a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8edbcaeffa0466743b8e61f266d4a75">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#af55b53ed8b9965ba83c3c596265dffab">Index</a> <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve this node's index in relation to its parent </p>
<dl class="section return"><dt>Returns</dt><dd>the index of this nod3 </dd></dl>

</div>
</div>
<a id="a4ea03580a944c3e09be51ddf893ca17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea03580a944c3e09be51ddf893ca17a">&#9670;&nbsp;</a></span>is_leaf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::is_leaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determine whether this node is a leaf node </p>
<dl class="section return"><dt>Returns</dt><dd>whether this node has no children </dd></dl>

</div>
</div>
<a id="acdcd0af02a9b11d50d6bf668053a6426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdcd0af02a9b11d50d6bf668053a6426">&#9670;&nbsp;</a></span>is_root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::is_root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determine whether this node is the root node </p>
<dl class="section return"><dt>Returns</dt><dd>whether this node has no parent </dd></dl>

</div>
</div>
<a id="a859e011f27c0c57a302c19044366ce95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859e011f27c0c57a302c19044366ce95">&#9670;&nbsp;</a></span>location()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#ae8a88474d71b9c972e491a04e5c60731">Int_location</a> <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::location </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>retrieve this node's location in the tree </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>Should I link to an explanation of the location type?</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>this node's location </dd></dl>

</div>
</div>
<a id="a56958185e0714a6c6c7fb78a8c94f637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56958185e0714a6c6c7fb78a8c94f637">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compares the topology of this node to another node </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>node to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the trees have different topology </dd></dl>

</div>
</div>
<a id="ae4b44de9d97a6b632ced96b55de3af18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b44de9d97a6b632ced96b55de3af18">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compare the topology of this node to another node </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>node to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the nodes have different topology </dd></dl>

</div>
</div>
<a id="a9c5984be6e40f35f72c625e85adafcad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5984be6e40f35f72c625e85adafcad">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a>&amp; <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>access the child nodes of this node by their indices </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Explain how index values map to the Index type</dd></dl>
<p>Retrieves a reference to the child node described by the index. The operator can be chained. for example, to access the third child of the second child of the fifth child of a node <code>n</code> </p><pre class="fragment">n[5][2][3];
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the child node, as an int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the node </dd></dl>

</div>
</div>
<a id="aa67327ed00e04cd4d703be4b706b5997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67327ed00e04cd4d703be4b706b5997">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a>&amp; <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read-only access the child nodes of this node by their indices </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the child node, as an int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the node </dd></dl>

</div>
</div>
<a id="a817713779475dee12f1d339e445b94eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817713779475dee12f1d339e445b94eb">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#ac6948f4082832147a7964339b9e115e7">Self</a>* <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read-only access to this node's parent </p>
<p>Ownership of a node is not equivalent to ownership of the entire tree, so it's not possible to obtain write access to a node's parent, only its children. Note that the return type is nullable, attempting to find the parent of a root node will return null. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Should I instead assert the node isn't root? (that would make this undefined behavior)</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A const pointer to the parent of this node (possibly nullptr) </dd></dl>

</div>
</div>
<a id="a7d5b29eac2b539cb75c3a08b2befa7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5b29eac2b539cb75c3a08b2befa7e6">&#9670;&nbsp;</a></span>points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Octree_1_1Node.html#a6eb076b3af39fb38303fdf0879b6ecf7">Point_range</a>&amp; <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>access to the content held by this node </p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the collection of point indices </dd></dl>

</div>
</div>
<a id="a8063c67e27eeb6ceb9c76d70b86890bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8063c67e27eeb6ceb9c76d70b86890bd">&#9670;&nbsp;</a></span>points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1Octree_1_1Node.html#a6eb076b3af39fb38303fdf0879b6ecf7">Point_range</a>&amp; <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read-only access to the content held by this node </p>
<dl class="section return"><dt>Returns</dt><dd>a read-only reference to the collection of point indices </dd></dl>

</div>
</div>
<a id="a01638decf3e8638c656174d30b8b8b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01638decf3e8638c656174d30b8b8b05">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>count the points contained by this node </p>
<dl class="section return"><dt>Returns</dt><dd>the number of points this node owns </dd></dl>

</div>
</div>
<a id="af6428be9387b9a7833f3158cca857852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6428be9387b9a7833f3158cca857852">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::split </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>split a node into subnodes </p>
<p>Only leaf nodes should be split. When a node is split it is no longer a leaf node. 8 Children are constructed automatically, and their values are set. Contents of this node are <em>not</em> propagated automatically. It's the responsibility of the caller to redistribute the points contained by a node after splitting </p>

</div>
</div>
<a id="a607dfbe8e6346c4968b3354d8e6c5995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a607dfbe8e6346c4968b3354d8e6c5995">&#9670;&nbsp;</a></span>unsplit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Point_index &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; Point_index &gt;::unsplit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>eliminate this node's children, making it a leaf node </p>
<p>When a node is un-split, its children are automatically deleted. After un-splitting a node it will be considered a leaf node </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><b>Octree</b></li><li class="navelem"><a class="el" href="classCGAL_1_1Octree_1_1Node.html">Node</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</div>
</body>
</html>
