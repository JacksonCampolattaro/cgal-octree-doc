<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="icon" type="image/png" href="../Manual/g-196x196-doc.png"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CGAL 5.1 - Octree: CGAL::Octree::Octree&lt; Point_range, Point_map &gt; Class Template Reference</title>
<!-- <link href="../Manual/tabs.css" rel="stylesheet" type="text/css"/> -->
<script type="text/javascript" src="../Manual/jquery.js"></script>
<script type="text/javascript" src="../Manual/dynsections.js"></script>
<!-- Manually include treeview and search to avoid bloat and to fix
     paths to the directory Manual . -->
<!-- $.treeview -->
<!-- $.search -->
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/searchdata.js"></script>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="../Manual/search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../Manual/search/search.js"></script>
<!-- Manually done below. -->
<link href="../Manual/stylesheet.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../Manual/cgal_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
      }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<script src="../Manual/hacks.js" type="text/javascript"></script>
<script src="modules.js" type="text/javascript"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://www.cgal.org/">cgal.org</a></li>
    <li><a href="../Manual/index.html">Top</a></li>
    <li><a href="../Manual/general_intro.html">Getting Started</a></li>
    <li><a href="../Manual/tutorials.html">Tutorials</a></li>
    <li><a href="../Manual/packages.html">Package Overview</a></li>
    <li><a href="../Manual/how_to_cite_cgal.html">Acknowledging CGAL</a></li>
  </ul>
  <!-- In a package SEARCHENGINE = false, so we cannot use 
       insertion. That's why we have to do it manually here. Notice
       that we also take pngs from the Manual. -->
  <div id="MSearchBox" class="MSearchBoxInactive">
    <span class="left">
      <img id="MSearchSelect" src="../Manual/search/mag_sel.png"
           onmouseover="return searchBox.OnSearchSelectShow()"
           onmouseout="return searchBox.OnSearchSelectHide()"
           alt=""/>
      <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)"
             onblur="searchBox.OnSearchFieldFocus(false)"
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
    </span><span class="right">
      <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../Manual/search/close.png" alt=""/></a>
    </span>
  </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CGAL 5.1 - Octree
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- Code below is usually inserted by doxygen when SEARCHENGINE =
     true. Notice that the path to the search directory is adjusted to
     the top-level.-->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../Manual/search",false,'Search');
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0"
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classCGAL_1_1Octree_1_1Octree.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="classCGAL_1_1Octree_1_1Octree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CGAL::Octree::Octree&lt; Point_range, Point_map &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__PkgOctreeRef.html">Octree Reference</a> &raquo; <a class="el" href="group__PkgOctreeClasses.html">Classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;CGAL/Octree.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Definition</h2>
<div class="textblock"><h3>template&lt;class Point_range, class Point_map = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt;<br />
class CGAL::Octree::Octree&lt; Point_range, Point_map &gt;</h3>

<p>a data structure for efficient computations in 3D space. </p>
<p>It builds a hierarchy of nodes which subdivide the space based on a collection of points. Each node represents an axis aligned cubic region of space. A node contains the range of points that are present in the region it defines, and it may contain eight other nodes which further subdivide the region.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Point_range</td><td>is a range type that provides random access iterators over the indices of a set of points. </td></tr>
    <tr><td class="paramname">Point_map</td><td>is a type that maps items in the range to Point data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="Octree_2Octree_build_from_Point_set_8cpp-example.html#_a0">Octree/Octree_build_from_Point_set.cpp</a>, <a class="el" href="Octree_2Octree_build_from_Point_vector_8cpp-example.html#_a0">Octree/Octree_build_from_Point_vector.cpp</a>, <a class="el" href="Octree_2Octree_build_with_custom_split_8cpp-example.html#_a0">Octree/Octree_build_with_custom_split.cpp</a>, <a class="el" href="Octree_2Octree_find_nearest_neighbor_8cpp-example.html#_a0">Octree/Octree_find_nearest_neighbor.cpp</a>, <a class="el" href="Octree_2Octree_grade_8cpp-example.html#_a0">Octree/Octree_grade.cpp</a>, <a class="el" href="Octree_2Octree_traversal_manual_8cpp-example.html#_a0">Octree/Octree_traversal_manual.cpp</a>, and <a class="el" href="Octree_2Octree_traversal_preorder_8cpp-example.html#_a0">Octree/Octree_traversal_preorder.cpp</a>.</dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Public Types</h2></td></tr>
<tr class="memitem:aadd7d77deada783ad284aca8655d4673"><td class="memItemLeft" align="right" valign="top"><a id="aadd7d77deada783ad284aca8655d4673"></a>
typedef <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">Octree</a>&lt; Point_range, Point_map &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#aadd7d77deada783ad284aca8655d4673">Self</a></td></tr>
<tr class="memdesc:aadd7d77deada783ad284aca8655d4673"><td class="mdescLeft">&#160;</td><td class="mdescRight">self typedef for convenience <br /></td></tr>
<tr class="separator:aadd7d77deada783ad284aca8655d4673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7976adaa1fa588736219fcb1eeb6b2"><td class="memItemLeft" align="right" valign="top"><a id="add7976adaa1fa588736219fcb1eeb6b2"></a>
typedef boost::property_traits&lt; Point_map &gt;::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#add7976adaa1fa588736219fcb1eeb6b2">Point</a></td></tr>
<tr class="memdesc:add7976adaa1fa588736219fcb1eeb6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The point type is deduced from the type of the property map used. <br /></td></tr>
<tr class="separator:add7976adaa1fa588736219fcb1eeb6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94ea980c59c03cc2882a2b292232071"><td class="memItemLeft" align="right" valign="top"><a id="ae94ea980c59c03cc2882a2b292232071"></a>
typedef CGAL::Kernel_traits&lt; <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#add7976adaa1fa588736219fcb1eeb6b2">Point</a> &gt;::<a class="el" href="classCGAL_1_1Octree_1_1Octree.html#ae94ea980c59c03cc2882a2b292232071">Kernel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#ae94ea980c59c03cc2882a2b292232071">Kernel</a></td></tr>
<tr class="memdesc:ae94ea980c59c03cc2882a2b292232071"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Kernel used is deduced from the point type. <br /></td></tr>
<tr class="separator:ae94ea980c59c03cc2882a2b292232071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b651138b6df6907d0b53349b5f3dfa0"><td class="memItemLeft" align="right" valign="top"><a id="a1b651138b6df6907d0b53349b5f3dfa0"></a>
typedef Kernel::FT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1b651138b6df6907d0b53349b5f3dfa0">FT</a></td></tr>
<tr class="memdesc:a1b651138b6df6907d0b53349b5f3dfa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The floating point type is decided by the Kernel. <br /></td></tr>
<tr class="separator:a1b651138b6df6907d0b53349b5f3dfa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1905aa159dae5ba29ace2913d188c4b5"><td class="memItemLeft" align="right" valign="top"><a id="a1905aa159dae5ba29ace2913d188c4b5"></a>
typedef <a class="el" href="classCGAL_1_1Octree_1_1Node.html">CGAL::Octree::Node</a>&lt; typename Point_range::iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a></td></tr>
<tr class="memdesc:a1905aa159dae5ba29ace2913d188c4b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Sub-tree / Octant type. <br /></td></tr>
<tr class="separator:a1905aa159dae5ba29ace2913d188c4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33eddfd39556537cbe6403719315db8"><td class="memItemLeft" align="right" valign="top"><a id="af33eddfd39556537cbe6403719315db8"></a>
typedef std::function&lt; bool(const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#af33eddfd39556537cbe6403719315db8">Split_criterion_function</a></td></tr>
<tr class="memdesc:af33eddfd39556537cbe6403719315db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that determines whether a node needs to be split when refining a tree. <br /></td></tr>
<tr class="separator:af33eddfd39556537cbe6403719315db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafadce25608cf6df277358e53cd3e8f6"><td class="memItemLeft" align="right" valign="top"><a id="aafadce25608cf6df277358e53cd3e8f6"></a>
typedef boost::iterator_range&lt; <a class="el" href="classCGAL_1_1Traversal__iterator.html">Traversal_iterator</a>&lt; const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#aafadce25608cf6df277358e53cd3e8f6">Node_range_const</a></td></tr>
<tr class="memdesc:aafadce25608cf6df277358e53cd3e8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A range that provides input-iterator access to the nodes of a tree. <br /></td></tr>
<tr class="separator:aafadce25608cf6df277358e53cd3e8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45a3b40a5168038a9723b7ffcc45de2"><td class="memItemLeft" align="right" valign="top"><a id="ad45a3b40a5168038a9723b7ffcc45de2"></a>
typedef std::function&lt; const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a> *(const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#ad45a3b40a5168038a9723b7ffcc45de2">Node_traversal_method_const</a></td></tr>
<tr class="memdesc:ad45a3b40a5168038a9723b7ffcc45de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that determines the next node in a traversal given the current one. <br /></td></tr>
<tr class="separator:ad45a3b40a5168038a9723b7ffcc45de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Construction, Destruction</h2></td></tr>
<tr class="memitem:aa73aecd8761bba806e05d46ed043b933"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#aa73aecd8761bba806e05d46ed043b933">Octree</a> (Point_range &amp;point_range, Point_map point_map=Point_map(), const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1b651138b6df6907d0b53349b5f3dfa0">FT</a> enlarge_ratio=1.2)</td></tr>
<tr class="memdesc:aa73aecd8761bba806e05d46ed043b933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an octree from a collection of points.  <a href="classCGAL_1_1Octree_1_1Octree.html#aa73aecd8761bba806e05d46ed043b933">More...</a><br /></td></tr>
<tr class="separator:aa73aecd8761bba806e05d46ed043b933"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Tree Building</h2></td></tr>
<tr class="memitem:a021487b63cb7496ba254c6fb31204760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a021487b63cb7496ba254c6fb31204760">refine</a> (const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#af33eddfd39556537cbe6403719315db8">Split_criterion_function</a> &amp;split_criterion)</td></tr>
<tr class="memdesc:a021487b63cb7496ba254c6fb31204760"><td class="mdescLeft">&#160;</td><td class="mdescRight">subdivide an octree's nodes and sub-nodes until it meets the given criteria  <a href="classCGAL_1_1Octree_1_1Octree.html#a021487b63cb7496ba254c6fb31204760">More...</a><br /></td></tr>
<tr class="separator:a021487b63cb7496ba254c6fb31204760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8402ff7fe455d43e373eac06c956ff6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#ad8402ff7fe455d43e373eac06c956ff6">refine</a> (size_t max_depth=10, size_t bucket_size=20)</td></tr>
<tr class="memdesc:ad8402ff7fe455d43e373eac06c956ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">refine an octree using a max depth and max number of points in a node as split criterion  <a href="classCGAL_1_1Octree_1_1Octree.html#ad8402ff7fe455d43e373eac06c956ff6">More...</a><br /></td></tr>
<tr class="separator:ad8402ff7fe455d43e373eac06c956ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f441cc60ca9d7886082aab9fd8d652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a01f441cc60ca9d7886082aab9fd8d652">grade</a> ()</td></tr>
<tr class="memdesc:a01f441cc60ca9d7886082aab9fd8d652"><td class="mdescLeft">&#160;</td><td class="mdescRight">eliminate large jumps in depth by splitting nodes that are much shallower than their neighbors  <a href="classCGAL_1_1Octree_1_1Octree.html#a01f441cc60ca9d7886082aab9fd8d652">More...</a><br /></td></tr>
<tr class="separator:a01f441cc60ca9d7886082aab9fd8d652"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Accessors</h2></td></tr>
<tr class="memitem:ab8cf40fa6f463a835053fbcf92b23150"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#ab8cf40fa6f463a835053fbcf92b23150">root</a> () const</td></tr>
<tr class="memdesc:ab8cf40fa6f463a835053fbcf92b23150"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides read-only access to the root node, and by extension the rest of the tree  <a href="classCGAL_1_1Octree_1_1Octree.html#ab8cf40fa6f463a835053fbcf92b23150">More...</a><br /></td></tr>
<tr class="separator:ab8cf40fa6f463a835053fbcf92b23150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6745f84d5a663e8c15654d46a82b918"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#ad6745f84d5a663e8c15654d46a82b918">operator[]</a> (int index) const</td></tr>
<tr class="memdesc:ad6745f84d5a663e8c15654d46a82b918"><td class="mdescLeft">&#160;</td><td class="mdescRight">access the child nodes of the root node by their indices  <a href="classCGAL_1_1Octree_1_1Octree.html#ad6745f84d5a663e8c15654d46a82b918">More...</a><br /></td></tr>
<tr class="separator:ad6745f84d5a663e8c15654d46a82b918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610bc75a2b709a119d0569fde3d18bc1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a610bc75a2b709a119d0569fde3d18bc1">max_depth_reached</a> () const</td></tr>
<tr class="memdesc:a610bc75a2b709a119d0569fde3d18bc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the deepest level reached by a leaf node in this tree.  <a href="classCGAL_1_1Octree_1_1Octree.html#a610bc75a2b709a119d0569fde3d18bc1">More...</a><br /></td></tr>
<tr class="separator:a610bc75a2b709a119d0569fde3d18bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c047087200dab941c77da81261f8c5b"><td class="memTemplParams" colspan="2">template&lt;class Traversal &gt; </td></tr>
<tr class="memitem:a5c047087200dab941c77da81261f8c5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#aafadce25608cf6df277358e53cd3e8f6">Node_range_const</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a5c047087200dab941c77da81261f8c5b">traverse</a> (const <a class="el" href="classTraversal.html">Traversal</a> &amp;traversal_method=<a class="el" href="classTraversal.html">Traversal</a>()) const</td></tr>
<tr class="memdesc:a5c047087200dab941c77da81261f8c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructs an input range of nodes using a tree walker function  <a href="classCGAL_1_1Octree_1_1Octree.html#a5c047087200dab941c77da81261f8c5b">More...</a><br /></td></tr>
<tr class="separator:a5c047087200dab941c77da81261f8c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2763b097b8f0650d68941eed7322b28"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#aa2763b097b8f0650d68941eed7322b28">locate</a> (const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#add7976adaa1fa588736219fcb1eeb6b2">Point</a> &amp;p) const</td></tr>
<tr class="memdesc:aa2763b097b8f0650d68941eed7322b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the leaf node which would contain a point  <a href="classCGAL_1_1Octree_1_1Octree.html#aa2763b097b8f0650d68941eed7322b28">More...</a><br /></td></tr>
<tr class="separator:aa2763b097b8f0650d68941eed7322b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f8afa6664c5b3532773601369b5dfb"><td class="memItemLeft" align="right" valign="top">Bbox&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a35f8afa6664c5b3532773601369b5dfb">bbox</a> (const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a> &amp;node) const</td></tr>
<tr class="memdesc:a35f8afa6664c5b3532773601369b5dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the bounding box of a node  <a href="classCGAL_1_1Octree_1_1Octree.html#a35f8afa6664c5b3532773601369b5dfb">More...</a><br /></td></tr>
<tr class="separator:a35f8afa6664c5b3532773601369b5dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9512b7bf2af4d964c091a246df227bd4"><td class="memTemplParams" colspan="2">template&lt;typename Point_output_iterator &gt; </td></tr>
<tr class="memitem:a9512b7bf2af4d964c091a246df227bd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a9512b7bf2af4d964c091a246df227bd4">nearest_k_neighbors_in_radius</a> (const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#add7976adaa1fa588736219fcb1eeb6b2">Point</a> &amp;search_point, <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1b651138b6df6907d0b53349b5f3dfa0">FT</a> search_radius_squared, std::size_t k, Point_output_iterator output) const</td></tr>
<tr class="memdesc:a9512b7bf2af4d964c091a246df227bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the K points in a tree that are nearest to the search point and within a specific radius  <a href="classCGAL_1_1Octree_1_1Octree.html#a9512b7bf2af4d964c091a246df227bd4">More...</a><br /></td></tr>
<tr class="separator:a9512b7bf2af4d964c091a246df227bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fe252a59c58455da3ea03fa3368c46"><td class="memTemplParams" colspan="2">template&lt;typename Point_output_iterator &gt; </td></tr>
<tr class="memitem:a69fe252a59c58455da3ea03fa3368c46"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a69fe252a59c58455da3ea03fa3368c46">nearest_k_neighbors</a> (const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#add7976adaa1fa588736219fcb1eeb6b2">Point</a> &amp;search_point, std::size_t k, Point_output_iterator output) const</td></tr>
<tr class="memdesc:a69fe252a59c58455da3ea03fa3368c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the K points in a tree that are nearest to the search point  <a href="classCGAL_1_1Octree_1_1Octree.html#a69fe252a59c58455da3ea03fa3368c46">More...</a><br /></td></tr>
<tr class="separator:a69fe252a59c58455da3ea03fa3368c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1390b6d068f8f4c8329aa8dc9a7cd3"><td class="memTemplParams" colspan="2">template&lt;typename Query , typename Node_output_iterator &gt; </td></tr>
<tr class="memitem:a5e1390b6d068f8f4c8329aa8dc9a7cd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a5e1390b6d068f8f4c8329aa8dc9a7cd3">intersecting_nodes</a> (const Query &amp;query, Node_output_iterator output) const</td></tr>
<tr class="memdesc:a5e1390b6d068f8f4c8329aa8dc9a7cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the leaf nodes that intersect with any primitive  <a href="classCGAL_1_1Octree_1_1Octree.html#a5e1390b6d068f8f4c8329aa8dc9a7cd3">More...</a><br /></td></tr>
<tr class="separator:a5e1390b6d068f8f4c8329aa8dc9a7cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Operators</h2></td></tr>
<tr class="memitem:ad384e039192d95b954a753afddbdcf6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#ad384e039192d95b954a753afddbdcf6b">operator==</a> (const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#aadd7d77deada783ad284aca8655d4673">Self</a> &amp;rhs) const</td></tr>
<tr class="memdesc:ad384e039192d95b954a753afddbdcf6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compares the topology of a pair of Octrees  <a href="classCGAL_1_1Octree_1_1Octree.html#ad384e039192d95b954a753afddbdcf6b">More...</a><br /></td></tr>
<tr class="separator:ad384e039192d95b954a753afddbdcf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffe8778cb21355e3cc617a7b0f76b30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#afffe8778cb21355e3cc617a7b0f76b30">operator!=</a> (const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#aadd7d77deada783ad284aca8655d4673">Self</a> &amp;rhs) const</td></tr>
<tr class="memdesc:afffe8778cb21355e3cc617a7b0f76b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">compares the topology of a pair of Octrees  <a href="classCGAL_1_1Octree_1_1Octree.html#afffe8778cb21355e3cc617a7b0f76b30">More...</a><br /></td></tr>
<tr class="separator:afffe8778cb21355e3cc617a7b0f76b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa73aecd8761bba806e05d46ed043b933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73aecd8761bba806e05d46ed043b933">&#9670;&nbsp;</a></span>Octree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::<a class="el" href="classCGAL_1_1Octree_1_1Octree.html">Octree</a> </td>
          <td>(</td>
          <td class="paramtype">Point_range &amp;&#160;</td>
          <td class="paramname"><em>point_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point_map&#160;</td>
          <td class="paramname"><em>point_map</em> = <code>Point_map()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1b651138b6df6907d0b53349b5f3dfa0">FT</a>&#160;</td>
          <td class="paramname"><em>enlarge_ratio</em> = <code>1.2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an octree from a collection of points. </p>
<p>The resulting octree will have a root node with no children that contains the points passed. That root node will have a bounding box that encloses all of the points passed, with padding according to the enlarge_ratio This single-node octree is valid and compatible with all <a class="el" href="classCGAL_1_1Octree_1_1Octree.html" title="a data structure for efficient computations in 3D space.">Octree</a> functionality, but any performance benefits are unlikely to be realized unless the tree is refined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_range</td><td>random access iterator over the indices of the points </td></tr>
    <tr><td class="paramname">point_map</td><td>maps the point indices to their coordinate locations </td></tr>
    <tr><td class="paramname">enlarge_ratio</td><td>the degree to which the bounding box should be enlarged </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a35f8afa6664c5b3532773601369b5dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f8afa6664c5b3532773601369b5dfb">&#9670;&nbsp;</a></span>bbox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Bbox <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::bbox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the bounding box of a node </p>
<p>Creates a cubic region representing a node. The size of the region depends on the node's depth in the tree. The location of the region depends on the node's location. The bounding box is useful for checking for collisions with a node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the node to determine the bounding box of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bounding box defined by that node's relationship to the tree </dd></dl>

</div>
</div>
<a id="a01f441cc60ca9d7886082aab9fd8d652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f441cc60ca9d7886082aab9fd8d652">&#9670;&nbsp;</a></span>grade()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::grade </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>eliminate large jumps in depth by splitting nodes that are much shallower than their neighbors </p>
<p>This function guarantees that any pair of adjacent nodes has a difference in depth no greater than 1. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>link to adjacent nodes explanation </dd></dl>

</div>
</div>
<a id="a5e1390b6d068f8f4c8329aa8dc9a7cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1390b6d068f8f4c8329aa8dc9a7cd3">&#9670;&nbsp;</a></span>intersecting_nodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Query , typename Node_output_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::intersecting_nodes </td>
          <td>(</td>
          <td class="paramtype">const Query &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Node_output_iterator&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the leaf nodes that intersect with any primitive </p>
<p>This function finds all the intersecting nodes and returns them as const pointers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Query</td><td>the primitive class (e.g. Sphere_3, Ray_3) </td></tr>
    <tr><td class="paramname">Node_output_iterator</td><td>an output iterator type that will accept node pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the primitive to check for intersections </td></tr>
    <tr><td class="paramname">output</td><td>the output iterator to add node references to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2763b097b8f0650d68941eed7322b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2763b097b8f0650d68941eed7322b28">&#9670;&nbsp;</a></span>locate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a>&amp; <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::locate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#add7976adaa1fa588736219fcb1eeb6b2">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the leaf node which would contain a point </p>
<p>Traverses the octree and finds the deepest cell that has a domain enclosing the point passed. The point passed must be within the region enclosed by the octree (bbox of the root node).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The point to find a node for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the node which would contain the point </dd></dl>

</div>
</div>
<a id="a610bc75a2b709a119d0569fde3d18bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610bc75a2b709a119d0569fde3d18bc1">&#9670;&nbsp;</a></span>max_depth_reached()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::max_depth_reached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the deepest level reached by a leaf node in this tree. </p>
<dl class="section return"><dt>Returns</dt><dd>the deepest level, where root is 0 </dd></dl>

</div>
</div>
<a id="a69fe252a59c58455da3ea03fa3368c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fe252a59c58455da3ea03fa3368c46">&#9670;&nbsp;</a></span>nearest_k_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Point_output_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::nearest_k_neighbors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#add7976adaa1fa588736219fcb1eeb6b2">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>search_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point_output_iterator&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the K points in a tree that are nearest to the search point </p>
<p>This function is equivalent to invoking nearest_k_neighbors_in_radius for an infinite radius. For a tree with K or fewer points, all points in the tree will be returned.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Point_output_iterator</td><td>an output iterator type that will accept points </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search_point</td><td>the location to find points near </td></tr>
    <tr><td class="paramname">k</td><td>the number of points to find </td></tr>
    <tr><td class="paramname">output</td><td>the output iterator to add the found points to (in order of increasing distance) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9512b7bf2af4d964c091a246df227bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9512b7bf2af4d964c091a246df227bd4">&#9670;&nbsp;</a></span>nearest_k_neighbors_in_radius()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename Point_output_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::nearest_k_neighbors_in_radius </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#add7976adaa1fa588736219fcb1eeb6b2">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>search_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1b651138b6df6907d0b53349b5f3dfa0">FT</a>&#160;</td>
          <td class="paramname"><em>search_radius_squared</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point_output_iterator&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the K points in a tree that are nearest to the search point and within a specific radius </p>
<p>This function guarantees that there are no closer points than the ones returned, but it does not guarantee that it will return at least K points. For a query where the search radius encloses K or fewer points, all enclosed points will be returned. If the search radius passed is too small, no points may be returned. This function is useful when the user already knows how sparse the points are, or if they don't care about points that are too far away. Setting a small radius may have performance benefits.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Point_output_iterator</td><td>an output iterator type that will accept points </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">search_point</td><td>the location to find points near </td></tr>
    <tr><td class="paramname">search_radius_squared</td><td>the size of the region to search within </td></tr>
    <tr><td class="paramname">k</td><td>the number of points to find </td></tr>
    <tr><td class="paramname">output</td><td>the output iterator to add the found points to (in order of increasing distance) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afffe8778cb21355e3cc617a7b0f76b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffe8778cb21355e3cc617a7b0f76b30">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#aadd7d77deada783ad284aca8655d4673">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compares the topology of a pair of Octrees </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>tree to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the trees have different topology </dd></dl>

</div>
</div>
<a id="ad384e039192d95b954a753afddbdcf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad384e039192d95b954a753afddbdcf6b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#aadd7d77deada783ad284aca8655d4673">Self</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compares the topology of a pair of Octrees </p>
<p>Trees may be considered equivalent even if they contain different points. Equivalent trees must have the same bounding box and the same node structure. <a class="el" href="classCGAL_1_1Octree_1_1Node.html" title="represents a single node of the tree. Alternatively referred to as a cell, octant,...">Node</a> structure is evaluated by comparing the root nodes using the node equality operator. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>Should I link to that?</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>tree to compare with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the trees have the same topology </dd></dl>

</div>
</div>
<a id="ad6745f84d5a663e8c15654d46a82b918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6745f84d5a663e8c15654d46a82b918">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a>&amp; <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>access the child nodes of the root node by their indices </p>
<p>my_tree[5] is equivalent to my_tree.root()[5]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the child node, as an int </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the node </dd></dl>

</div>
</div>
<a id="a021487b63cb7496ba254c6fb31204760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021487b63cb7496ba254c6fb31204760">&#9670;&nbsp;</a></span>refine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::refine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#af33eddfd39556537cbe6403719315db8">Split_criterion_function</a> &amp;&#160;</td>
          <td class="paramname"><em>split_criterion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>subdivide an octree's nodes and sub-nodes until it meets the given criteria </p>
<p>The split criterion can be any function pointer that takes a <a class="el" href="classCGAL_1_1Octree_1_1Node.html" title="represents a single node of the tree. Alternatively referred to as a cell, octant,...">Node</a> pointer and returns a boolean value (where true implies that a <a class="el" href="classCGAL_1_1Octree_1_1Node.html" title="represents a single node of the tree. Alternatively referred to as a cell, octant,...">Node</a> needs to be split). It's safe to call this function repeatedly, and with different criterion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">split_criterion</td><td>rule to use when determining whether or not a node needs to be subdivided </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8402ff7fe455d43e373eac06c956ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8402ff7fe455d43e373eac06c956ff6">&#9670;&nbsp;</a></span>refine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::refine </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_depth</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bucket_size</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>refine an octree using a max depth and max number of points in a node as split criterion </p>
<p>This is equivalent to calling: </p><pre class="fragment">refine(Split_criterion::Max_depth_or_bucket_size(max_depth, bucket_size));
</pre><p>This functionality is provided for consistency with older octree implementations which did not allow for custom split criterion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_depth</td><td>deepest a tree is allowed to be (nodes at this depth will not be split) </td></tr>
    <tr><td class="paramname">bucket_size</td><td>maximum points a node is allowed to contain </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8cf40fa6f463a835053fbcf92b23150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cf40fa6f463a835053fbcf92b23150">&#9670;&nbsp;</a></span>root()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classCGAL_1_1Octree_1_1Octree.html#a1905aa159dae5ba29ace2913d188c4b5">Node</a>&amp; <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::root </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provides read-only access to the root node, and by extension the rest of the tree </p>
<dl class="section return"><dt>Returns</dt><dd>a const reference to the root node of the tree </dd></dl>

</div>
</div>
<a id="a5c047087200dab941c77da81261f8c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c047087200dab941c77da81261f8c5b">&#9670;&nbsp;</a></span>traverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Point_range , class Point_map  = Identity_property_map&lt;typename Point_range::iterator::value_type&gt;&gt; </div>
<div class="memtemplate">
template&lt;class Traversal &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html#aafadce25608cf6df277358e53cd3e8f6">Node_range_const</a> <a class="el" href="classCGAL_1_1Octree_1_1Octree.html">CGAL::Octree::Octree</a>&lt; Point_range, Point_map &gt;::traverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTraversal.html">Traversal</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal_method</em> = <code><a class="el" href="classTraversal.html">Traversal</a>()</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>constructs an input range of nodes using a tree walker function </p>
<p>The result is a boost range created from iterators that meet the criteria defining a Forward Input Iterator This is completely compatible with standard foreach syntax. Dereferencing returns a const reference to a node. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo:</a></b></dt><dd>Perhaps I should add some discussion of recommended usage</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classTraversal.html" title="A Traversal provides the functions needed to traverse the nodes of an octree using a Traversal_iterat...">Traversal</a></td><td>type of the walker rule </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">traversal_method</td><td>the rule to use when determining the order of the sequence of points produced </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a forward input iterator over the nodes of the tree </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!-- The footer div is not part of the default but we require it to
move the footer to the bottom of the page. -->
<div id="footer">
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>CGAL</b></li><li class="navelem"><b>Octree</b></li><li class="navelem"><a class="el" href="classCGAL_1_1Octree_1_1Octree.html">Octree</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</div>
</body>
</html>
